# ESP32 Servo Motion Kit 仕様書（ドラフト）

## 目的とスコープ

* ESP32 向け Arduino（v3.0+）ライブラリで、ホビー用 PWM サーボと TTL/バスサーボを同期制御できるチェーン可能な API を提供する。
* ブラウザ UI から WebSerial で設定・動作を編集し、ESP32 に送信して即座に試せる体験を実現する。
* WebSerial プロトコルで受信した設定を適用し、ライブラリ経由でサーボを駆動する ESP32 ファームウェアを提供する。
* 範囲外: 電気設計/PCB/BOM、サーボ本体のファーム改変、クラウド連携。

## 利用方針

* 内部構造ではなく「ユーザーがどう動かすか」から設計を積み上げる。
* Arduino API は流れるように書けるチェーンスタイルで、ジョイント/ポーズ/モーション定義を簡潔に。
* デフォルトは高レベルで安全; 詳細調整は必要なときにだけ開く。
* UI 主導で設定 → WebSerial 送信 → 即試行までを一貫させ、設定変更に再フラッシュを要求しない。

## 想定ユーザーとゴール

* マイコン/ロボットを素早く動かしたいメイカー・ホビイスト。
* 授業やデモで再現性のあるポーズ/モーションを作りたい教育者・展示担当。
* ゴール: 迅速なセットアップ、最小限の手順での操作、ブラウザからの即時試行、複数軸の同期動作。

## UX とフロー（ユースケース別）

* **ライブラリ単体利用（コード中心）**

  * Arduino スケッチ内でジョイント/ポーズ/モーション/シーケンスを定義し、`setup()` で初期化、`loop()` で play/stop/query を呼ぶ。
  * PC/スマホ UI は使わず、シリアルモニタ等でログ確認や微調整。設定変更はスケッチ再ビルドで適用。
* **UI でモーション作成 → 専用ファームで検証 → ライブラリ用ヘッダ出力**

  * ブラウザ UI でジョイント → ポーズ → モーション/シーケンスを編集・プレビュー。ジョイントグループは送信前に展開し、無効軸は除外。
  * ESP32 に専用ファームウェア（UI 連携用）を書き込み、WebSerial でデバイス JSON を送信して動作確認・保存。再生中の状態/ログ取得、緊急停止が可能。
  * 確認後、UI からライブラリ向けヘッダ（単一 .h）を出力。初期化コードとモーション/ポーズ定義を含み、ユーザーはスケッチ側で取り込み、`play` などの API を呼べば再生できる。

## コア概念

* **サーボ**: PWM（180/360 度）や TTL/バス（マルチドロップ/ハーフデュプレックスなど）を含むサーボチャネルを管理。GPIO/バス割り当て、オフセット/ニュートラル、位置・速度・トルク上限（対応する場合）、キャリブレーションを設定可能。プロトコル差分はライブラリで吸収。
* **ジョイント**: 論理軸。1 つ以上のサーボチャネルにマッピングでき、ゲイン/オフセットでミラー動作や負荷分担（同一軸にサーボを複数重ねてトルクを共有）を表現。
* **ジョイントグループ**: UI 専用の論理集合。複数ジョイントをまとめて選択/操作するラベルで、ESP32 側には実体を持たない。UI でグループを指定したポーズは送信前に各ジョイントへ展開される。
* **ポーズ**: ジョイント目標をまとめた名前付きセット（角度/位置、速度・トルクヒントを含む場合あり）。軸ごとに有効/無効フラグを持ち、無効な軸はグループ展開時に除外され、ESP32 への対象軸にも含まれない。
* **モーション**: ポーズ間の遷移。時間（duration）とプロファイル（イージングカーブ）を持つ。
* **シーケンス**: モーション/ポーズの順序リスト。ループやトリガーを持つ再生単位。
* **プロファイル（イージング）**: 時間に対する位置/速度カーブの定義。リニア、イージイン/アウト、独自カーブなどをモーションに適用する。

## コンポーネントと役割

* **Arduino ライブラリ (ESP32, v3.0+)**

  * PWM ピンと TTL バスラインの設定/接続をサポートし、混在利用を可能にする。
  * ジョイントビルダー: 軸定義、サーボ割り当て、リミット、ニュートラル/オフセット、キャリブレーション。
  * ポーズ/モーションビルダー: ポーズ作成、遷移・シーケンス定義、同期再生。
  * ランタイム: 同期更新スケジューラ、安全リミット、ソフトスタート/ストップ。
  * API はスケッチ的な流れで書けることを最優先する。
* **ESP32 ファームウェア (WebSerial ブリッジ)**

  * WebSerial セッション管理、JSON コマンド/設定の受信、ログ/状態の返却。
  * デバイス向け軽量 JSON をフラッシュ/FS に保存し、起動時にデフォルトをロード可能。
  * 再生/停止コマンドを実行し、進行状況やエラーを報告。
* **ブラウザ UI**

  * ジョイント/ポーズ/モーションをタイムラインで編集できるリッチエディタ。
  * WebSerial で接続/切断、ポート一覧、前回デバイスの再接続。
  * 設定検証、モーションカーブのプレビュー、送信前のタイミング確認。
  * 設定送信と実行トリガー、ログ/テレメトリの取得表示。

## データモデルと設定

### メタ

UI/デバイス共通のスキーマ識別子とバージョン管理に使う。

```json
{
  "meta": {
    "schema": "motionkit",
    "version": "0.1.0"
  }
}
```

#### リッチUI JSON

```json
{
  "meta": {
    "schema": "motionkit",
    "version": "0.1.0"
  }
}
```

#### シンプルJSON（デバイス向け）

```json
{
  "meta": {
    "schema": "motionkit",
    "version": "0.1.0"
  }
}
```

#### C++ API（生成ヘッダ＆実行）

```cpp
#define MOTIONKIT_SCHEMA "motionkit"
#define MOTIONKIT_VERSION "0.1.0"
```

##### Servo の C++ API（生成ヘッダ＆実行：最小サンプル）

以下は **シンプルJSON（デバイス向け）相当**のサーボ定義を、Arduino/C++ 側で最小限に記述して動かす例。
（詳細な設定項目は後続で追加する前提とし、ここでは全体の流れのみ示す。）

```cpp
#include <MotionKit.h>

MotionKit kit;

void setup() {
  kit.begin();

  // Servo 定義（最小）
  // - まずは PWM のみを想定
  // - 角度（deg）を基本単位として扱う
  auto s1 = kit.servo("s1")
              .pwm(18)
              .position();

  // 必要に応じて最終状態を検証（必須不足や矛盾があれば false）
  if (!s1.ok()) {
    // エラー内容はハンドルから取得
    ESP_LOGE("MotionKit", "servo s1 invalid: %s", s1.lastErrorStr());
  }

  // 再生・実行系 API は後続の設計で追加（ポーズ/モーション/シーケンスなど）
}

void loop() {
  kit.update();
}
```

---

### Servo（共通）

サーボは物理チャネル（PWM 出力、TTL/バスなど）に紐づく最小単位。UI/ライブラリともに **角度（deg）を基本単位**として扱い、プロトコル差分（PWM/TTL）はライブラリで吸収する。

* **180°（位置制御）**を基本として扱う。
* **360°（連続回転）**も同一スキーマで表現できるようにし、`mode` により挙動を切り替える。

  * `mode: "position"` … 角度（deg）を目標として位置制御（180°サーボ向け）。
  * `mode: "wheel"` … 角度ではなく回転速度（deg/s 相当の正負値）を目標として連続回転（360°サーボ向け）。

> 注: 詳細フィールド定義（direction/neutral/limit/speed/offset 等）は後続で追加する。

---

### Servo（PWM）

PWM サーボは GPIO ピンに直接接続され、PWM パルス幅で制御される。
UI/設定は角度（deg）を基本単位として扱い、PWM 出力（µs）へのマッピングはライブラリで吸収する。

> 注: PWM 固有フィールド（pin / pwm パラメータ等）の詳細は後続で追加する。

---

### Servo（TTL / バス）

TTL/バスサーボは UART 等のバスライン上でアドレス指定して制御する。複数台を同一配線で扱える。

> 注: 本ドラフトではまず PWM を実装対象とし、TTL/バスの詳細項目は順次追加する。

---

#### リッチUI JSON（例：PWM）

```json
{
  "servos": [
    {
      "id": "s1",
      "name": "shoulder_left",
      "type": "pwm",
      "mode": "position",
      "pin": 18
    }
  ]
}
```

#### リッチUI JSON（例：360°連続回転を同一スキーマで表現）

```json
{
  "servos": [
    {
      "id": "s2",
      "name": "wheel_servo",
      "type": "pwm",
      "mode": "wheel",
      "pin": 19
    }
  ]
}
```

#### シンプルJSON（デバイス向け、例）

デバイス向けは実行に必要な最小項目に絞る。初期実装では **短縮キーは用いず**、可読性を優先する（将来的に CBOR 等でバイナリ転送する場合は、エンコード側でサイズ最適化を行う）。

**シンプルJSON（例）**

```json
{
  "servos": [
    {
      "id": "s1",
      "type": "pwm",
      "mode": "position",
      "pin": 18
    }
  ]
}
```

**対応する C++ API（最小）**

```cpp
auto s1 = kit.servo("s1")
              .pwm(18)
              .position();
```

> 注: 詳細項目は後続で拡張する。

#### 変換と解釈のルール

* UI / API は角度（deg）を基本単位として扱う。
* PWM/TTL などのプロトコル差分はライブラリで吸収する。
* 詳細な変換・補正・安全ルールは後続で定義する。

# ESP32 Servo Motion Kit 仕様書（ドラフト）

## 目的とスコープ

* ESP32 向け Arduino（v3.0+）ライブラリで、ホビー用 PWM サーボと TTL/バスサーボを同期制御できるチェーン可能な API を提供する。
* ブラウザ UI から WebSerial で設定・動作を編集し、ESP32 に送信して即座に試せる体験を実現する。
* WebSerial プロトコルで受信した設定を適用し、ライブラリ経由でサーボを駆動する ESP32 ファームウェアを提供する。
* 範囲外: 電気設計/PCB/BOM、サーボ本体のファーム改変、クラウド連携。

## 利用方針

* 内部構造ではなく「ユーザーがどう動かすか」から設計を積み上げる。
* Arduino API は流れるように書けるチェーンスタイルで、ジョイント/ポーズ/モーション定義を簡潔に。
* デフォルトは高レベルで安全; 詳細調整は必要なときにだけ開く。
* UI 主導で設定 → WebSerial 送信 → 即試行までを一貫させ、設定変更に再フラッシュを要求しない。

## 想定ユーザーとゴール

* マイコン/ロボットを素早く動かしたいメイカー・ホビイスト。
* 授業やデモで再現性のあるポーズ/モーションを作りたい教育者・展示担当。
* ゴール: 迅速なセットアップ、最小限の手順での操作、ブラウザからの即時試行、複数軸の同期動作。

## UX とフロー（ユースケース別）

* **ライブラリ単体利用（コード中心）**

  * Arduino スケッチ内でジョイント/ポーズ/モーション/シーケンスを定義し、`setup()` で初期化、`loop()` で play/stop/query を呼ぶ。
  * PC/スマホ UI は使わず、シリアルモニタ等でログ確認や微調整。設定変更はスケッチ再ビルドで適用。
* **UI でモーション作成 → 専用ファームで検証 → ライブラリ用ヘッダ出力**

  * ブラウザ UI でジョイント → ポーズ → モーション/シーケンスを編集・プレビュー。ジョイントグループは送信前に展開し、無効軸は除外。
  * ESP32 に専用ファームウェア（UI 連携用）を書き込み、WebSerial でデバイス JSON を送信して動作確認・保存。再生中の状態/ログ取得、緊急停止が可能。
  * 確認後、UI からライブラリ向けヘッダ（単一 .h）を出力。初期化コードとモーション/ポーズ定義を含み、ユーザーはスケッチ側で取り込み、`play` などの API を呼べば再生できる。

## コア概念

* **サーボ**: PWM（180/360 度）や TTL/バス（マルチドロップ/ハーフデュプレックスなど）を含むサーボチャネルを管理。GPIO/バス割り当て、オフセット/ニュートラル、位置・速度・トルク上限（対応する場合）、キャリブレーションを設定可能。プロトコル差分はライブラリで吸収。
* **ジョイント**: 論理軸。1 つ以上のサーボチャネルにマッピングでき、ゲイン/オフセットでミラー動作や負荷分担（同一軸にサーボを複数重ねてトルクを共有）を表現。
* **ジョイントグループ**: UI 専用の論理集合。複数ジョイントをまとめて選択/操作するラベルで、ESP32 側には実体を持たない。UI でグループを指定したポーズは送信前に各ジョイントへ展開される。
* **ポーズ**: ジョイント目標をまとめた名前付きセット（角度/位置、速度・トルクヒントを含む場合あり）。軸ごとに有効/無効フラグを持ち、無効な軸はグループ展開時に除外され、ESP32 への対象軸にも含まれない。
* **モーション**: ポーズ間の遷移。時間（duration）とプロファイル（イージングカーブ）を持つ。
* **シーケンス**: モーション/ポーズの順序リスト。ループやトリガーを持つ再生単位。
* **プロファイル（イージング）**: 時間に対する位置/速度カーブの定義。リニア、イージイン/アウト、独自カーブなどをモーションに適用する。

## Arduino API（ドラフト）

Arduino 側はチェインスタイルで設定を積み上げ、呼び出した順に **即時に登録/更新**される。`.done()` は任意で、必要なタイミングで **バリデーション結果（成功/失敗）を取得**するために使う。

* チェイン呼び出しは都度内部状態へ反映される（作成途中の状態も保持される）。
* `.done()` を呼ばない場合でも設定は保持され、後から `.done()` で結果取得できる。
* 追加・更新の過程で発生したエラーは内部に蓄積され、ユーザーが任意の方法で取得できる。

### サーボ登録（例）

```cpp
MotionKit kit;

void setup() {
  kit.begin();

  // 180° サーボ（位置）
  kit.servo("s1")
      .pwm(18)
      .position()
      .neutralDeg(90)
      .limitDeg(0, 180)
      .speedLimitDegS(240)
      .offsetDeg(2.5)
      .deadbandDeg(0.5);

  // 結果が欲しいときだけ done() を呼ぶ
  if (!kit.servo("s1").done()) {
    Serial.println(kit.lastErrorStr());
  }

  // 360° サーボ（連続回転）
  kit.servo("s2")
      .pwm(19)
      .wheel()
      .speedLimitDegS(720)
      .deadbandDeg(1.0);
}
```

### エラー取得（ドラフト）

エラーは `.done()` 以外でも取得できるようにする。ログ出力は別途定義し、Arduino 側のログレベルに応じて出力可否を制御する。

* `bool ok() const` : 現在の状態がエラーを含まないか（グローバル）
* `MotionKitError lastError() const` : 最後のエラーコード
* `const char* lastErrorStr() const` : 最後のエラー文字列
* `size_t errorCount() const` : 未処理エラー数
* `MotionKitError popError()` : 先頭（または末尾）の未処理エラーを取り出し、キューから削除
* `void clearErrors()` : 未処理エラーをクリア（次回のチェイン操作をクリーンに開始したい場合）

#### `.done()` の意味（全体バリデーション）

`.done()` は **全体状態（登録済み設定一式）**のバリデーションを行う。チェイン操作は逐次反映されるため、`.done()` は commit ではなく「今の状態が実行可能か」を判定する。

* `bool done()` : 全体を検証し、成功/失敗を返す（失敗時はエラーを追加）
* `bool validate()` : `done()` と同義（読みやすさのため別名として提供可）

> 推奨: チェイン操作が成功しているかの即時確認には `ok()` を使い、実行前・保存前など「確定したい」タイミングで `done()` を呼ぶ。

### ログ出力方針（ESP-IDF / Arduino）

ライブラリのログは ESP-IDF の `ESP_LOGx` を利用する（`ESP_LOGE/W/I/D/V`）。Arduino IDE 側でログレベル設定済みであることを前提とし、ライブラリ側は **適切なレベルでログを分類して出力**する。

#### ログレベルの対応

* **ERROR**: 実行不能・回復不能な失敗（例: 必須フィールド不足、ピン/バス競合、致命的な範囲矛盾）

  * `ESP_LOGE(tag, ...)`
* **WARN**: 実行は可能だが危険/非推奨（例: limit が広すぎる、ニュートラルが範囲外、速度上限未設定で急加速の可能性）

  * `ESP_LOGW(tag, ...)`
* **INFO**: 通常の状態遷移・設定確定（例: サーボ登録/更新、モード変更、保存/ロード完了）

  * `ESP_LOGI(tag, ...)`
* **DEBUG**: 開発者向け詳細（例: µs 変換結果、クランプ適用、補間ステップ、内部状態）

  * `ESP_LOGD(tag, ...)`
* **VERBOSE**: 高頻度ログ（例: ループ毎の目標値、送信パケット詳細、タイムステップ）

  * `ESP_LOGV(tag, ...)`

#### ログ方針

* デフォルトのログ出力量は Arduino 側のログレベル設定に従う。

* パフォーマンスのため、高頻度経路（ループ/ISR 相当）は `ESP_LOGV` に限定し、通常は無効化される前提とする。

* `.done()` で検出したエラーは `ESP_LOGE` で出力しつつ、エラーキューにも蓄積する。

* 非推奨/注意事項は `ESP_LOGW` とし、必要に応じて自動補正（クランプ等）した場合は `ESP_LOGW` と `ESP_LOGD` を併用する。

* ライブラリ内部はログレベル（例: ERROR/WARN/INFO/DEBUG/TRACE）を持つ。

* Arduino 側のログレベル設定に応じて、Serial 等へ出力する。

* デフォルトは WARN 以上を出力し、設定で変更可能にする。

## コンポーネントと役割

* **Arduino ライブラリ (ESP32, v3.0+)**

  * PWM ピンと TTL バスラインの設定/接続をサポートし、混在利用を可能にする。
  * ジョイントビルダー: 軸定義、サーボ割り当て、リミット、ニュートラル/オフセット、キャリブレーション。
  * ポーズ/モーションビルダー: ポーズ作成、遷移・シーケンス定義、同期再生。
  * ランタイム: 同期更新スケジューラ、安全リミット、ソフトスタート/ストップ。
  * API はスケッチ的な流れで書けることを最優先する。
* **ESP32 ファームウェア (WebSerial ブリッジ)**

  * WebSerial セッション管理、JSON コマンド/設定の受信、ログ/状態の返却。
  * デバイス向け軽量 JSON をフラッシュ/FS に保存し、起動時にデフォルトをロード可能。
  * 再生/停止コマンドを実行し、進行状況やエラーを報告。
* **ブラウザ UI**

  * ジョイント/ポーズ/モーションをタイムラインで編集できるリッチエディタ。
  * WebSerial で接続/切断、ポート一覧、前回デバイスの再接続。
  * 設定検証、モーションカーブのプレビュー、送信前のタイミング確認。
  * 設定送信と実行トリガー、ログ/テレメトリの取得表示。

## データモデルと設定

### メタ

UI/デバイス共通のスキーマ識別子とバージョン管理に使う。

```json
{
  "meta": {
    "schema": "motionkit",
    "version": "0.1.0"
  }
}
```

#### リッチUI JSON

```json
{
  "meta": {
    "schema": "motionkit",
    "version": "0.1.0"
  }
}
```

#### シンプルJSON（デバイス向け）

```json
{
  "meta": {
    "schema": "motionkit",
    "version": "0.1.0"
  }
}
```

#### C++ API（生成ヘッダ＆実行）

```cpp
#define MOTIONKIT_SCHEMA "motionkit"
#define MOTIONKIT_VERSION "0.1.0"
```

---

### Servo（共通）

サーボは物理チャネル（PWM 出力、TTL/バスなど）に紐づく最小単位。UI/ライブラリともに **角度（deg）を基本単位**として扱い、プロトコル差分（PWM/TTL）はライブラリで吸収する。

* **180°（位置制御）**を基本として扱う。
* **360°（連続回転）**も同一スキーマで表現できるようにし、`mode` により挙動を切り替える。

  * `mode: "position"` … 角度（deg）を目標として位置制御（180°サーボ向け）。
  * `mode: "wheel"` … 角度ではなく回転速度（deg/s 相当の正負値）を目標として連続回転（360°サーボ向け）。

#### 共通フィールド（コア）

* `id` : サーボ識別子（文字列、デバイス内で一意）
* `name` : UI 表示名（任意、推奨）
* `type` : `"pwm" | "ttl"`（将来拡張可）
* `mode` : `"position" | "wheel"`
* `direction` : `1 | -1`（反転）
* `neutralDeg` : ニュートラル角（deg）
* `limitDeg` : 動作範囲（deg）

  * `min` / `max`

#### 速度上限（推奨）

同期制御で「速すぎる」動きやギア破損を防ぐため、速度上限を **deg/s** で設定できる。

* `speedLimitDegS` : 角速度の上限（deg/s）

  * `mode: "position"` の場合、ポーズ間遷移での最大角速度として扱う。
  * `mode: "wheel"` の場合、目標速度（deg/s 相当）の最大値としてクランプする。

> 注: PWM 180°サーボは通常フィードバックを持たないため、`speedLimitDegS` は「目標値の変化速度（コマンド側）」として解釈する。

#### キャリブレーション（推奨）

* `offsetDeg` : ニュートラル補正（deg）
* `scale` : 角度スケール補正（例: 左右差の微調整、任意）
* `deadbandDeg` : デッドバンド（deg）

  * 小さな目標変化によるジッタ（細かい振動）を抑制するためのしきい値。
  * `mode: "position"` の場合、前回目標との差分が `deadbandDeg` 未満なら更新をスキップできる。
  * `mode: "wheel"` の場合、目標速度の絶対値が `deadbandDeg` 未満なら 0（停止）として扱える。

#### 起動時挙動（推奨）

* `startup` :

  * `enabled` : 起動時に出力を有効化するか
  * `moveToNeutral` : 起動時にニュートラルへ移動するか
  * `rampMs` : ソフトスタート時間（ms）

---

### Servo（PWM）

PWM サーボは GPIO ピンに直接接続され、PWM パルス幅で制御される。
内部では `limitDeg`・`neutralDeg` を基準に `pwm.minUs/maxUs` へマッピングして出力する。

#### PWM 固有フィールド

* `pin` : GPIO 番号
* `pwm` : PWM パラメータ

  * `freqHz` : 周波数（通常 50）
  * `minUs` / `maxUs` : パルス幅範囲（µs）

---

### Servo（TTL / バス）

TTL/バスサーボは UART 等のバスライン上でアドレス指定して制御する。複数台を同一配線で扱える。

#### TTL 固有フィールド（案）

* `bus` :

  * `busId` : `"uart0"` など
  * `protocol` : `"dynamixel" | "feetech" | "lx16a" | ...`（将来拡張）
  * `address` : バス上の ID

> 注: 本ドラフトではまず PWM を実装対象とし、TTL/バスの詳細項目は順次追加する。

---

#### リッチUI JSON（例：PWM）

```json
{
  "servos": [
    {
      "id": "s1",
      "name": "shoulder_left",
      "type": "pwm",
      "mode": "position",

      "pin": 18,
      "pwm": { "freqHz": 50, "minUs": 500, "maxUs": 2500 },

      "direction": 1,
      "neutralDeg": 90,
      "limitDeg": { "min": 0, "max": 180 },
      "speedLimitDegS": 240,

      "offsetDeg": 2.5,
      "scale": 1.0,
      "deadbandDeg": 0.5,
      "startup": { "enabled": true, "moveToNeutral": true, "rampMs": 300 }
    }
  ]
}
```

#### リッチUI JSON（例：360°連続回転を同一スキーマで表現）

```json
{
  "servos": [
    {
      "id": "s2",
      "name": "wheel_servo",
      "type": "pwm",
      "mode": "wheel",

      "pin": 19,
      "pwm": { "freqHz": 50, "minUs": 1000, "maxUs": 2000 },

      "direction": -1,
      "neutralDeg": 0,
      "limitDeg": { "min": -360, "max": 360 },
      "speedLimitDegS": 720,

      "offsetDeg": 0,
      "scale": 1.0,
      "deadbandDeg": 1.0,
      "startup": { "enabled": true, "moveToNeutral": true, "rampMs": 200 }
    }
  ]
}
```

#### シンプルJSON（デバイス向け、例）

デバイス向けは実行に必要な最小項目に絞る。初期実装では **短縮キーは用いず**、可読性を優先する（将来的に CBOR 等でバイナリ転送する場合は、エンコード側でサイズ最適化を行う）。

```json
{
  "servos": [
    {
      "id": "s1",
      "type": "pwm",
      "mode": "position",
      "pin": 18,
      "direction": 1,
      "neutralDeg": 90,
      "limitDeg": { "min": 0, "max": 180 },
      "speedLimitDegS": 240,
      "offsetDeg": 2.5,
      "deadbandDeg": 0.5
    }
  ]
}
```

#### 変換と解釈のルール

* UI / API は角度（deg）を基本とし、PWM 生成時に `pwm.minUs/maxUs` と `limitDeg` を用いて µs へマッピングする。
* `direction` は **角度と速度の符号**に適用される。
* `offsetDeg` は `neutralDeg` に加算して内部ニュートラルとして扱う。
* `speedLimitDegS` は上限としてクランプし、プロファイルにより滑らかに制限する。
